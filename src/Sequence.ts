import {defaults} from 'lodash';
import {ArrayStorage} from './ArrayStorage';
import {Atom} from './Atom';
import {Ident} from './Ident';
import {Op, OpKind, InsertOp, RemoveOp} from './Op';
import {Options} from './Options';
import {Segment} from './Segment';
import {Storage} from './Storage';

/**
 * The identifier allocation strategy to use at a specified depth.
 */
enum Strategy {
  
  /**
   * Generate identifiers by adding a value to the previous digit.
   */
  AddFromLeft = 1,
  
  /**
   * Generate identifiers by subtracting a value to the next digit.
   */
  SubtractFromRight = 2,
  
}

/**
 * A CmRDT sequence that implements the LSEQ algorithm to support
 * concurrent simultaneous editing.
 */
export class Sequence<T> {
  
  /**
   * The unique replica id.
   */
  replica: string
  
  private options: Options<T>
  private storage: Storage<T>
  private strategies: Strategy[]
  private time: number
  
  /**
   * Creates an instance of Sequence<T>.
   * @param replica The unique replica id for the sequence.
   * @param options Options that customize the sequence.
   * @returns An instance of Sequence<T>. 
   */
  constructor(replica: string, options?: Options<T>) {
    this.replica = replica;
    this.options = Options(options);
    this.storage = this.options.storage || new ArrayStorage<T>();
    this.strategies = [];
    this.time = 0;
    this.storage.add(new Ident(0, [Segment(0, this.replica)]), null);
    this.storage.add(new Ident(0, [Segment(this.getWidthAtDepth(0), this.replica)]), null);
  }
  
  /**
   * Gets the number of items in the sequence.
   * @returns The number of items in the sequence.
   */
  size(): number {
    return this.storage.size() - 2;
  }
  
  /**
   * Gets the depth of the sequence. (The maximum number of segments used by
   * an atom in the sequence.)
   * @returns The depth of the sequence.
   */
  depth(): number {
    return Object.keys(this.strategies).length;
  }
  
  /**
   * Inserts a value into the sequence at the specified position.
   * @param value The value to insert.
   * @param pos   The position at which to insert the value.
   * @returns An InsertOp that can be applied to other Sequences
   *          to reproduce the insertion.
   */
  insert(value: T, pos: number): InsertOp {
    let before = this.storage.get(pos);
    let after  = this.storage.get(pos + 1);
    let id     = this.createIdent(before.id, after.id);
    let op     = new InsertOp(id, value);
    this.apply(op);
    return op;
  }
  
  /**
   * Appends a value to the end of the sequence.
   * @param value The value to append.
   * @returns An InsertOp that can be applied to other Sequences
   *          to reproduce the insertion.
   */
  append(value: T): InsertOp {
    return this.insert(value, this.size());
  }
  
  /**
   * Removes the value at the specified position from the sequence.
   * @param pos The position of the value to remove.
   * @returns An RemoveOp that can be applied to other Sequences
   *          to reproduce the removal.
   */
  remove(pos: number): RemoveOp {
    let atom = this.storage.get(pos);
    if (atom) {
      let op = new RemoveOp(atom.id)
      this.apply(op);
      return op;
    }
    return null;
  }
  
  /**
   * Gets the value at the specified position in the sequence.
   * @param pos The desired position.
   * @returns The value at that position,
   *          or undefined if no such value exists. 
   */
  get(pos: number): T {
    const atom = this.storage.get(pos + 1);
    return atom ? atom.value : undefined;
  }
  
  /**
   * Applies a function to each of the values in the sequence.
   * @param func The function to apply.
   */
  forEach(func: { (T): void }): void {
    this.storage.forEach((atom) => func(atom.value));
  }
  
  /**
   * Applies a transformation function to each of the values in the sequence.
   * @param func The transformation function to apply.
   * @returns An array containing the results of the function calls.
   */ 
  map<R>(func: { (T): R }): R[] {
    return this.storage.map((atom) => func(atom.value));
  }
  
  /**
   * Converts the sequence to an array.
   * @returns An array representation of the values in the sequence.
   */ 
  toArray(): T[] {
    return this.storage.map((atom) => atom.value);
  }
  
  /**
   * Converts the sequence to a compact object suitable for serialization.
   * @returns A serializable object.
   */
  toJSON(): Object {
    return {
      r: this.replica,
      t: this.time,
      s: this.strategies,
      d: this.storage.map((atom) => [atom.id.toString(), atom.value])
    }
  }
  
  /**
   * Applies the specified Op to the sequence. Typically this is used
   * to apply operations that have been generated by remote sequences.
   * @param op The Op to apply.
   */
  apply(op: Op): void {
    switch (op.kind) {
      case OpKind.Insert:
        let insertOp = <InsertOp> op; 
        this.storage.add(insertOp.id, insertOp.value);
        break;
      case OpKind.Remove:
        let removeOp = <RemoveOp> op; 
        this.storage.remove(removeOp.id);
        break;
      default:
        throw new Error(`Unknown op kind ${op.kind}`);
    }
  }
  
  /**
   * Creates a new Ident whose value lies somewhere between two other Idents.
   * @param before The Ident that should come directly before the new Ident.
   * @param before The Ident that should come directly after the new Ident.
   * @returns The newly-generated Ident.
   */
  private createIdent(before: Ident, after: Ident): Ident {
    let distance: number = 0;
    let depth: number = -1;
    let min: number = 0;
    let max: number = 0;
    
    while (distance < 1) {
      depth++;
      let left = before.get(depth);
      let right = after.get(depth);
      min = left ? left.digit : 0;
      max = right ? right.digit : this.getWidthAtDepth(depth);
      distance = max - min - 1;
    }
    
    let boundary = Math.min(distance, this.options.maxDistance);
    let delta = Math.floor(Math.random() * boundary) + 1;
    let strategy = this.getStrategyAtDepth(depth);
    
    let ident = new Ident(++this.time, before.slice(depth, this.replica));
    
    if (strategy == Strategy.AddFromLeft) {
      ident.add(Segment(min + delta, this.replica));
    }
    else {
      ident.add(Segment(max - delta, this.replica));
    }
    
    return ident;
  }
  
  /**
   * Gets the maximum addressable digit at the specified depth. This is
   * generally 2^(depth + startingWidth) - 1, with a maximum of 2^53 - 1
   * (the largest integer that can be stored in a Number.)
   * @param depth The desired depth.
   * @returns The maximum addressable digit at the specified depth.
   */
  private getWidthAtDepth(depth: number): number {
    let power = depth + this.options.startingWidth;
    if (power > 53) power = 53;
    return Math.pow(2, power) - 1;
  }
  
  /**
   * Gets the digit allocation strategy for the specified depth.
   * If none has been selected, one is chosen at random.
   * @param depth The desired depth.
   * @returns The Strategy to use at that depth.
   */
  private getStrategyAtDepth(depth: number): Strategy {
    let strategy = this.strategies[depth];
    if (!strategy) {
      let random = Math.floor(Math.random() * 2) + 1;
      strategy = this.strategies[depth] = <Strategy> random;
    }
    return strategy;
  }
  
}